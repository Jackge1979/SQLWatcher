[{"type":"Oracle","data":[
{"title":"查询RMAN的所有备份信息",
"sql":"SELECT A.RECID BS_KEY,
       C.RECID BP_KEY,
       CASE
         WHEN A.BACKUP_TYPE = 'L' THEN
          'Archived Redo Logs'
         WHEN A.BACKUP_TYPE = 'D' AND A.INCREMENTAL_LEVEL IS NULL THEN
          'Datafile Full Backup'
         WHEN A.BACKUP_TYPE = 'I' OR A.INCREMENTAL_LEVEL IS NOT NULL THEN
          'Incremental Backup'
       END BACKUP_TYPE,
       A.INCREMENTAL_LEVEL,
       AA.BS_BYTES,
       TO_CHAR(A.START_TIME, 'YYYY-MM-DD HH24:MI:SS') START_TIME,
       TO_CHAR(A.COMPLETION_TIME, 'YYYY-MM-DD HH24:MI:SS') END_TIME,
       A.ELAPSED_SECONDS,
       C.HANDLE PIECE_NAME,
       C.DEVICE_TYPE,
       C.TAG,
       AA.BS_STATUS,
       AA.BS_COMPRESSED,
       A.CONTROLFILE_INCLUDED,
       A.KEEP,
       A.KEEP_UNTIL,
       A.KEEP_OPTIONS,
       ------ data file -------- 
       B.FILE#,
       B.INCREMENTAL_LEVEL DF_INCREMENTAL_LEVEL,
       (SELECT NB.NAME FROM V$DATAFILE NB WHERE NB.FILE# = B.FILE#) DATAFILENAME,
       B.USED_CHANGE_TRACKING,
       B.CHECKPOINT_CHANGE# || '' DF_CHECKPOINT_CHANGE#,
       B.CHECKPOINT_TIME DF_CHECKPOINT_TIME,
       ------ archive log file --------
       D.THREAD#,
       D.SEQUENCE#,
       D.RESETLOGS_CHANGE#,
       D.FIRST_CHANGE#,
       D.FIRST_TIME,
       D.NEXT_CHANGE#,
       D.NEXT_TIME,
       ------ spfile --------
       E.MODIFICATION_TIME,
       E.DB_UNIQUE_NAME,
       ------ control file --------
       F.CREATION_TIME,
       F.CHECKPOINT_CHANGE# || '' CF_CHECKPOINT_CHANGE#,
       F.CHECKPOINT_TIME CF_CHECKPOINT_TIME,
       F.FILESIZE_DISPLAY
  FROM V$BACKUP_SET A
  LEFT OUTER JOIN V$BACKUP_FILES AA
    ON (AA.BS_KEY = A.RECID AND AA.FILE_TYPE = 'PIECE')
  LEFT OUTER JOIN V$BACKUP_DATAFILE B
    ON (A.SET_STAMP = B.SET_STAMP AND A.SET_COUNT = B.SET_COUNT)
  LEFT OUTER JOIN V$BACKUP_PIECE C
    ON (A.SET_STAMP = C.SET_STAMP AND A.SET_COUNT = C.SET_COUNT)
  LEFT OUTER JOIN V$BACKUP_ARCHIVELOG_DETAILS D
    ON (D.BTYPE_KEY = A.RECID)
  LEFT OUTER JOIN V$BACKUP_SPFILE E
    ON (A.SET_STAMP = E.SET_STAMP AND A.SET_COUNT = E.SET_COUNT)
  LEFT OUTER JOIN V$BACKUP_CONTROLFILE_DETAILS F
    ON (F.BTYPE_KEY = A.RECID)
 ORDER BY A.RECID, A.RECID, B.FILE#, D.THREAD#, D.SEQUENCE#;
"},
{"title":"查询归档日志的生成情况",
"sql":"通过视图GV$ARCHIVED_LOG可以查询到日志的生成情况，如下所示：
SELECT A.THREAD# THREAD#,
       A.F_TIME F_TIME,
       ROUND(SUM(A.BLOCKS * A.BLOCK_SIZE) / 1024 / 1024) 每天归档日志量_M,
       ROUND(SUM(A.BLOCKS * A.BLOCK_SIZE) / 1024 / 1024 / 24, 2) 每小时平均归档日志量_M,
       COUNT(1)  归档文件数
  FROM (SELECT DISTINCT SEQUENCE#,
                        THREAD#,
                        BLOCKS,
                        BLOCK_SIZE,
                        TO_CHAR(FIRST_TIME, 'yyyy-mm-dd') F_TIME
          FROM GV$ARCHIVED_LOG T
         WHERE T.FIRST_TIME <= SYSDATE) A
 GROUP BY A.F_TIME, A.THREAD#
 ORDER BY 1, 2 DESC;
"},
{
"title":"查询ASM磁盘的使用情况",
"sql":"SELECT A.GROUP_NUMBER,
       A.DISK_NUMBER,
       A.NAME,
       A.PATH,
       A.STATE,
       A.MOUNT_STATUS,
       A.TOTAL_MB,
       A.FREE_MB,
       A.CREATE_DATE,
       A.MOUNT_DATE,
       A.LIBRARY,
       A.OS_MB
  FROM V$ASM_DISK A
  ORDER BY  A.GROUP_NUMBER,
       A.DISK_NUMBER;
"
},
{
"title":"查询ASM磁盘组的使用情况",
"sql":"SELECT DI.GROUP_NUMBER,
       DI.NAME,
       DI.BLOCK_SIZE,
       DI.STATE,
       DI.TYPE,
       DI.TOTAL_MB,
       DI.FREE_MB,
       DI.COMPATIBILITY,
       DI.VOTING_FILES,
       DI.OFFLINE_DISKS
  FROM V$ASM_DISKGROUP DI
 ORDER BY DI.GROUP_NUMBER;"
},
{
"title":"查询数据库闪回空间的使用情况",
"sql":"通过视图V$RECOVERY_FILE_DEST可以查询闪回空间的使用情况，其SQL如下所示：
SELECT NAME,
       TRUNC(SPACE_LIMIT/1024/1024/1024, 3) LIMIT_GB,
       TRUNC(SPACE_USED/1024/1024/1024, 3) USED_GB,
       TRUNC(SPACE_USED / SPACE_LIMIT, 3) \"USED%\",
       TRUNC(SPACE_RECLAIMABLE, 3) RECLAIM,
       NUMBER_OF_FILES
  FROM V$RECOVERY_FILE_DEST V
 WHERE V.SPACE_LIMIT <> 0;

若想查询详细使用情况，可以执行如下的SQL语句：
SELECT NVL(FRAU.FILE_TYPE, 'Total:') FILE_TYPE,
       SUM(ROUND(FRAU.PERCENT_SPACE_USED / 100 * RFD.SPACE_LIMIT / 1024 / 1024 / 1024,3)) USED_GB,
       SUM(FRAU.PERCENT_SPACE_USED) PERCENT_SPACE_USED,
       SUM(FRAU.PERCENT_SPACE_RECLAIMABLE) PERCENT_SPACE_RECLAIMABLE,
       SUM(ROUND(FRAU.PERCENT_SPACE_RECLAIMABLE / 100 * RFD.SPACE_LIMIT / 1024 / 1024 / 1024,3)) RECLAIM_GB,
       SUM(FRAU.NUMBER_OF_FILES) NUMBER_OF_FILES
  FROM V$FLASH_RECOVERY_AREA_USAGE FRAU, V$RECOVERY_FILE_DEST RFD
 GROUP BY ROLLUP(FILE_TYPE);
"
},
{
"title":"查询到数据库的增长情况",
"sql":"可以通过视图DBA_HIST_TBSPC_SPACE_USAGE来获取数据库的增长情况，具体查询语句及结果如下所示：
SELECT TO_CHAR(DATETIME, 'YYYY-MM-DD') DATETIME,
       TRUNC(SUM(TS_USED_SIZE) / 1024 / 1024) TS_USED_SIZE_M,
       TRUNC(SUM(TS_SIZE) / 1024 / 1024) TS_SIZE_M,
       TRUNC(SUM(TS_MAXSIZE) / 1024 / 1024) TS_MAXSIZE_M
  FROM (SELECT A.NAME, B.*
          FROM V$TABLESPACE A,
               (SELECT TABLESPACE_ID TS#,
                       TRUNC(TO_DATE(RTIME, 'MM/DD/YYYY HH24:MI:SS')) DATETIME,
                       (MAX(TABLESPACE_USEDSIZE * 8 * 1024)) TS_USED_SIZE,
                       (MAX(V.TABLESPACE_SIZE * 8 * 1024)) TS_SIZE,
                       (MAX(TABLESPACE_MAXSIZE * 8 * 1024)) TS_MAXSIZE
                  FROM DBA_HIST_TBSPC_SPACE_USAGE V
                 WHERE TRUNC(TO_DATE(RTIME, 'MM/DD/YYYY HH24:MI:SS')) >=
                       TRUNC(SYSDATE - 15)
                 GROUP BY TABLESPACE_ID,
                          TRUNC(TO_DATE(RTIME, 'MM/DD/YYYY HH24:MI:SS'))
                 ORDER BY TABLESPACE_ID,
                          TRUNC(TO_DATE(RTIME, 'MM/DD/YYYY HH24:MI:SS'))) B
         WHERE A.TS# = B.TS#)
 GROUP BY TO_CHAR(DATETIME, 'YYYY-MM-DD')
 ORDER BY DATETIME;

 若是需要按照表空间来展示，则可以运行如下的代码：
SELECT A.NAME,
       B.TS#,
       TO_CHAR(DATETIME, 'YYYY-MM-DD') DATETIME,
       TS_USED_SIZE_M,
       TS_SIZE_M,
       TS_MAXSIZE_M
  FROM V$TABLESPACE A,
       (SELECT TABLESPACE_ID TS#,
               TRUNC(TO_DATE(RTIME, 'MM/DD/YYYY HH24:MI:SS')) DATETIME,
               TRUNC(MAX(TABLESPACE_USEDSIZE * 8 * 1024)/1024/1024) TS_USED_SIZE_M,
               TRUNC(MAX(V.TABLESPACE_SIZE * 8 * 1024)/1024/1024) TS_SIZE_M,
               TRUNC(MAX(TABLESPACE_MAXSIZE * 8 * 1024)/1024/1024) TS_MAXSIZE_M
          FROM DBA_HIST_TBSPC_SPACE_USAGE V
         WHERE TRUNC(TO_DATE(RTIME, 'MM/DD/YYYY HH24:MI:SS')) >=
               TRUNC(SYSDATE - 7)
         GROUP BY TABLESPACE_ID,
                  TRUNC(TO_DATE(RTIME, 'MM/DD/YYYY HH24:MI:SS'))
         ORDER BY TABLESPACE_ID,
                  TRUNC(TO_DATE(RTIME, 'MM/DD/YYYY HH24:MI:SS'))) B
 WHERE A.TS# = B.TS#
 ORDER BY B.TS#, B.DATETIME;
"
},
{
"title":"如何跟踪expdp和SQL*Plus命令",
"sql":"可以使用trace选项来跟踪expdp命令，如下所示：
expdp \'/ AS SYSDBA\' directory=DATA_PUMP_DIR schemas=SCOTT dumpfile=test_query_lhr_scott_02.dmp parfile=/tmp/scottfile.par log=test_query_lhr_scott_02.log trace=4a0300

若想跟踪exp命令的话，可以使用操作系统命令strace，如下所示：
strace exp n1/n1 tables=scott.emp file=a.dmp

strace -c -p 25805

操作系统命令strace也可以跟踪SQL*Plus命令，跟踪的命令很简单：
strace -o /tmp/output.txt -T -tt -e trace=all  sqlplus / as sysdba

Unix系统下跟踪SQL*Plus命令使用truss命令，如下所示：
truss -dfaie -o /tmp/sched_trace.out.02271 sqlplus '/as sysdba'
"
},
{
"title":"如何彻底停止expdp进程",
"sql":"在使用expdp命令时，不小心按了CTRL+C组合键,然后又输入exit命令（或者网络中断等异常现象），导致expdp进程不存在，但Oracle数据库的会话仍存在，所以dmp文件也一直在增长。在这种情况下的处理办法如下所示：
1、检查expdp进程是否还在
ps -ef | grep expdp
若存在，则可用kill -9 process命令杀掉expdp的进程。

2、检查会话是否仍存在，若存在则把相关的会话杀掉（注意：先使用命令“ALTER SYSTEM KILL SESSION”在数据库级别杀掉会话，然后在OS级别使用kill -9杀掉进程），如无杀会话的权限则可以将相关的表DROP掉，表名可以使用如下的SQL来查询：
SELECT * FROM DBA_DATAPUMP_SESSIONS;
SELECT * FROM DBA_DATAPUMP_JOBS;
例如：
SYS@orclasm > SELECT * FROM DBA_DATAPUMP_SESSIONS;
OWNER_NAME JOB_NAME                     INST_ID SADDR            SESSION_TYPE
---------- ------------------------- ---------- ---------------- --------------
LHR        SYS_EXPORT_SCHEMA_04               1 00000000A8B71D98 MASTER
LHR        SYS_EXPORT_SCHEMA_04               1 00000000AB98AFC8 WORKER

SYS@orclasm > DROP TABLE LHR.SYS_EXPORT_SCHEMA_04 PURGE;
Table dropped.

SYS@orclasm >  SELECT * FROM DBA_DATAPUMP_SESSIONS;
no rows selected

SYS@orclasm > SELECT * FROM DBA_DATAPUMP_JOBS;
no rows selected
使用相同的办法也删除从视图DBA_DATAPUMP_JOBS中查询出来的表，直到2个视图无记录。

3、删除导出的dmp文件。如不删除，则重新执行expdp命令时，会报dmp文件已存在。
这里作者给出自己常用的一个SQL语句，可以查询expdp的相关会话的详细信息，如下所示：

SET LINE 9999
COL OWNER_NAME FOR A10
COL JOB_NAME FOR A25
COL OPERATION FOR A10
COL JOB_MODE FOR A10
COL STATE FOR A15
COL OSUSER FOR A10
COL \"DEGREE|ATTACHED|DATAPUMP\" FOR A25
COL SESSION_INFO FOR A20  

SELECT DS.INST_ID,
       DJ.OWNER_NAME,
       DJ.JOB_NAME,
       TRIM(DJ.OPERATION) OPERATION,
       TRIM(DJ.JOB_MODE) JOB_MODE,
       DJ.STATE,
       DJ.DEGREE || ',' || DJ.ATTACHED_SESSIONS || ',' ||DJ.DATAPUMP_SESSIONS \"DEGREE|ATTACHED|DATAPUMP\",
       DS.SESSION_TYPE,
       S.OSUSER ,
       (SELECT S.SID || ',' || S.SERIAL# || ',' || P.SPID
          FROM GV$PROCESS P
         WHERE S.PADDR = P.ADDR
           AND S.INST_ID = P.INST_ID) SESSION_INFO
  FROM DBA_DATAPUMP_JOBS DJ --GV$DATAPUMP_JOB  
  FULL OUTER JOIN DBA_DATAPUMP_SESSIONS DS --GV$DATAPUMP_SESSION
    ON (DJ.JOB_NAME = DS.JOB_NAME AND DJ.OWNER_NAME = DS.OWNER_NAME)
  LEFT OUTER JOIN GV$SESSION S
    ON (S.SADDR = DS.SADDR AND DS.INST_ID = S.INST_ID)
 ORDER BY DJ.OWNER_NAME, DJ.JOB_NAME;
"
},
{
"title":"RMAN可以跨版本恢复吗",
"sql":"答案是可以跨版本恢复的，但是有很多限制条件。对于跨小版本的恢复很容易，例如从11.2.0.1恢复到11.2.0.3版本的数据库。可以依次还原SPFILE、控制文件和数据文件，然后恢复数据库，使用STARTUP UPGRADE命令打开数据库，最后一步是使用catupgrd.sql脚本对失效的对象进行编译即可。对于跨大版本的恢复有很多限制条件，例如从10.2.0.2恢复到11.2.0.3版本的数据库。恢复步骤和小版本一样，打开数据库的时候可以使用命令：“ALTER DATABASE OPEN RESETLOGS UPGRADE;”。将Oracle 10g恢复到Oracle 11g上，需要满足2个条件，①必须在Oracle 10g上先执行脚本“@?/rdbms/admin/utlu112i.sql”，然后再进行备份，否则RESTORE之后的升级将失败。②Oracle 10g的版本必须大于10.2.0.2，即Oracle采用RMAN恢复到高版本的数据库依然要遵循Oracle数据库的升级流程图"
},
{
"title":"在UNDO表空间数据文件丢失的情况下如何恢复",
"sql":"恢复大约可以分为3种情况：
①有备份，这种情况下直接采用备份的文件进行恢复即可。
②无备份但是有完整的归档文件存在，这种情况下可以使用命令“ALTER DATABASE CREATE DATAFILE 文件号 AS '/u03/app/oracle/oradata/ora1024g/undotbs01.dbf' size 50m;”来创建丢失的UNDO文件，然后使用“RECOVER DATAFILE 文件号;”进行恢复数据库文件即可。
③无备份归档文件丢失，在这种情况下的恢复比较复杂。首先应该切换UNDO表空间到一个新建的UNDO表空间中，并设置原有表空间的管理模式为手动管理模式，然后将隐含参数“_OFFLINE_ROLLBACK_SEGMENTS”设置为TRUE，一些关键性的命令如下所示：
ALTER SYSTEM SET UNDO_TABLESPACE=UNDOTBS2 SCOPE=SPFILE;
ALTER SYSTEM SET UNDO_MANAGEMENT=MANUAL SCOPE=SPFILE;
ALTER SYSTEM SET \"_OFFLINE_ROLLBACK_SEGMENTS\"=TRUE SCOPE=SPFILE;
ALTER SYSTEM SET \"_CORRUPTED_ROLLBACK_SEGMENTS\"='_SYSSMU1$','_SYSSMU2$','_SYSSMU3$','_SYSSMU4$','_SYSSMU5$','_SYSSMU6$','_SYSSMU7$','_SYSSMU8$','_SYSSMU9$','_SYSSMU10$' SCOPE=SPFILE;
CREATE UNDO TABLESPACE UNDOTBS1 DATAFILE '/U03/APP/ORACLE/ORADATA/ORA1024G/UNDOTBS01.DBF' SIZE 50M AUTOEXTEND ON;
ALTER SYSTEM SET UNDO_TABLESPACE=UNDOTBS1  SCOPE=SPFILE;
ALTER SYSTEM SET UNDO_MANAGEMENT=AUTO  SCOPE=SPFILE;
ALTER SYSTEM RESET \"_OFFLINE_ROLLBACK_SEGMENTS\" SCOPE=SPFILE SID='*';
ALTER SYSTEM RESET \"_CORRUPTED_ROLLBACK_SEGMENTS\" SCOPE=SPFILE SID='*';
"
},
{
"title":"数据泵中NETWORK_LINK选项的作用是什么",
"sql":"数据泵expdp生成的文件默认是存放在服务端的，而exp生成的文件是存放在客户端的。使用数据泵的NETWORK_LINK参数，可以在本地的数据库中创建一个指向远程数据库的DBLINK，在执行导出expdp时，指定NETWORK_LINK参数为DBLINK名称，就可以直接将远程数据库的数据导出到本地数据库里创建的DIRECTORY下。在执行导入命令impdp的时候也可以使用NETWORK_LINK参数。如果不想在源端或目标端生成dmp文件而直接将需要的数据导入目标端数据库，那么可以直接使用impdp带NETWORK_LINK参数，这样可以直接执行impdp从而绕过了expdp的步骤。"
},
{
"title":"TWO_TASK环境变量的作用是什么",
"sql":"在Linux环境下，可以设置TWO_TASK环境变量，当用户连接数据库且没有指定服务名时，会自动利用TWO_TASK的设置作为环境变量连接数据库。其中，TWO_TASK的值为tnsnames.ora文件中配置的值。示例如下所示：
[LHRDB1:oracle]:/oracle>ORACLE_SID=
[LHRDB1:oracle]:/oracle>TWO_TASK=
[LHRDB1:oracle]:/oracle>sqlplus lhr/lhr
SQL*Plus: Release 11.2.0.4.0 Production on Mon Oct 31 16:17:38 2016
Copyright (c) 1982, 2013, Oracle.  All rights reserved.
ERROR:
ORA-12162: TNS:net service name is incorrectly specified
[LHRDB1:oracle]:/oracle>more $ORACLE_HOME/net*/ad*/tns*
# tnsnames.ora Network Configuration File: /oracle/app/oracle/product/11.2.0/db/network/admin/tnsnames.ora
# Generated by Oracle configuration tools.
lhrdb =
  (DESCRIPTION =
    (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.59.130)(PORT = 1521)) 
    (CONNECT_DATA =
      (SERVER = DEDICATED)
      (SERVICE_NAME = lhrdb)
    )
  )
[LHRDB1:oracle]:/oracle>export TWO_TASK=lhrdb
[LHRDB1:oracle]:/oracle>sqlplus lhr/lhr
SQL*Plus: Release 11.2.0.4.0 Production on Mon Oct 31 16:17:53 2016
Copyright (c) 1982, 2013, Oracle.  All rights reserved.
Connected to:
Oracle Database 11g Enterprise Edition Release 11.2.0.4.0 - 64bit Production
With the Partitioning, Real Application Clusters, Automatic Storage Management, OLAP,
Data Mining and Real Application Testing options
LHR@lhrdb> 
[LHRDB1:oracle]:/oracle>sqlplus / as sysdba
SQL*Plus: Release 11.2.0.4.0 Production on Mon Oct 31 16:18:07 2016
Copyright (c) 1982, 2013, Oracle.  All rights reserved.
ERROR:
ORA-01017: invalid username/password; logon denied
Enter user-name: 

需要注意的是，当配置了TWO_TASK环境变量后，就无法使用操作系统验证来登录数据库了，会报ORA-01031: insufficient privileges的错误。

类似地，在Windows环境下的变量是LOCAL，其设置方法和Linux下的TWO_TASK一致，如下所示：
C:\\Users\\boc>sqlplus lhr/lhr
SQL*Plus: Release 11.2.0.1.0 Production on Mon Oct 31 16:28:25 2016
Copyright (c) 1982, 2010, Oracle.  All rights reserved.
ERROR:
ORA-12560: TNS:protocol adapter error
Enter user-name:
C:\\Users\\boc>more \"%ORACLE_HOME%/network/admin/tnsnames.ora\"
# tnsnames.ora Network Configuration File: D:\\app\\oracle\\product\\11.2.0.1\\network\\admin\\tnsnames.ora
# Generated by Oracle configuration tools.
lhrdb =
  (DESCRIPTION =
    (ADDRESS = (PROTOCOL = TCP)(HOST = 22.188.194.64)(PORT = 1521))
    (CONNECT_DATA =
      (SERVER = DEDICATED)
      (SERVICE_NAME = lhrdb)
    )
  )
C:\\Users\\boc>set LOCAL=lhrdb
C:\\Users\\boc>sqlplus lhr/lhr
SQL*Plus: Release 11.2.0.1.0 Production on Mon Oct 31 16:29:25 2016
Copyright (c) 1982, 2010, Oracle.  All rights reserved.
Connected to:
Oracle Database 11g Enterprise Edition Release 11.2.0.4.0 - 64bit Production
With the Partitioning, Real Application Clusters, Automatic Storage Management, OLAP,
Data Mining and Real Application Testing options
SQL> 
"
}
]}]
