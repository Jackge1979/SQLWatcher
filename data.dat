[{"type":"Oracle","data":[
{"title":"查询RMAN的所有备份信息",
"sql":"SELECT A.RECID BS_KEY,
       C.RECID BP_KEY,
       CASE
         WHEN A.BACKUP_TYPE = 'L' THEN
          'Archived Redo Logs'
         WHEN A.BACKUP_TYPE = 'D' AND A.INCREMENTAL_LEVEL IS NULL THEN
          'Datafile Full Backup'
         WHEN A.BACKUP_TYPE = 'I' OR A.INCREMENTAL_LEVEL IS NOT NULL THEN
          'Incremental Backup'
       END BACKUP_TYPE,
       A.INCREMENTAL_LEVEL,
       AA.BS_BYTES,
       TO_CHAR(A.START_TIME, 'YYYY-MM-DD HH24:MI:SS') START_TIME,
       TO_CHAR(A.COMPLETION_TIME, 'YYYY-MM-DD HH24:MI:SS') END_TIME,
       A.ELAPSED_SECONDS,
       C.HANDLE PIECE_NAME,
       C.DEVICE_TYPE,
       C.TAG,
       AA.BS_STATUS,
       AA.BS_COMPRESSED,
       A.CONTROLFILE_INCLUDED,
       A.KEEP,
       A.KEEP_UNTIL,
       A.KEEP_OPTIONS,
       ------ data file -------- 
       B.FILE#,
       B.INCREMENTAL_LEVEL DF_INCREMENTAL_LEVEL,
       (SELECT NB.NAME FROM V$DATAFILE NB WHERE NB.FILE# = B.FILE#) DATAFILENAME,
       B.USED_CHANGE_TRACKING,
       B.CHECKPOINT_CHANGE# || '' DF_CHECKPOINT_CHANGE#,
       B.CHECKPOINT_TIME DF_CHECKPOINT_TIME,
       ------ archive log file --------
       D.THREAD#,
       D.SEQUENCE#,
       D.RESETLOGS_CHANGE#,
       D.FIRST_CHANGE#,
       D.FIRST_TIME,
       D.NEXT_CHANGE#,
       D.NEXT_TIME,
       ------ spfile --------
       E.MODIFICATION_TIME,
       E.DB_UNIQUE_NAME,
       ------ control file --------
       F.CREATION_TIME,
       F.CHECKPOINT_CHANGE# || '' CF_CHECKPOINT_CHANGE#,
       F.CHECKPOINT_TIME CF_CHECKPOINT_TIME,
       F.FILESIZE_DISPLAY
  FROM V$BACKUP_SET A
  LEFT OUTER JOIN V$BACKUP_FILES AA
    ON (AA.BS_KEY = A.RECID AND AA.FILE_TYPE = 'PIECE')
  LEFT OUTER JOIN V$BACKUP_DATAFILE B
    ON (A.SET_STAMP = B.SET_STAMP AND A.SET_COUNT = B.SET_COUNT)
  LEFT OUTER JOIN V$BACKUP_PIECE C
    ON (A.SET_STAMP = C.SET_STAMP AND A.SET_COUNT = C.SET_COUNT)
  LEFT OUTER JOIN V$BACKUP_ARCHIVELOG_DETAILS D
    ON (D.BTYPE_KEY = A.RECID)
  LEFT OUTER JOIN V$BACKUP_SPFILE E
    ON (A.SET_STAMP = E.SET_STAMP AND A.SET_COUNT = E.SET_COUNT)
  LEFT OUTER JOIN V$BACKUP_CONTROLFILE_DETAILS F
    ON (F.BTYPE_KEY = A.RECID)
 ORDER BY A.RECID, A.RECID, B.FILE#, D.THREAD#, D.SEQUENCE#;
"},
{"title":"查询归档日志的生成情况",
"sql":"通过视图GV$ARCHIVED_LOG可以查询到日志的生成情况，如下所示：
SELECT A.THREAD# THREAD#,
       A.F_TIME F_TIME,
       ROUND(SUM(A.BLOCKS * A.BLOCK_SIZE) / 1024 / 1024) 每天归档日志量_M,
       ROUND(SUM(A.BLOCKS * A.BLOCK_SIZE) / 1024 / 1024 / 24, 2) 每小时平均归档日志量_M,
       COUNT(1)  归档文件数
  FROM (SELECT DISTINCT SEQUENCE#,
                        THREAD#,
                        BLOCKS,
                        BLOCK_SIZE,
                        TO_CHAR(FIRST_TIME, 'yyyy-mm-dd') F_TIME
          FROM GV$ARCHIVED_LOG T
         WHERE T.FIRST_TIME <= SYSDATE) A
 GROUP BY A.F_TIME, A.THREAD#
 ORDER BY 1, 2 DESC;
"},
{
"title":"查询ASM磁盘的使用情况",
"sql":"SELECT A.GROUP_NUMBER,
       A.DISK_NUMBER,
       A.NAME,
       A.PATH,
       A.STATE,
       A.MOUNT_STATUS,
       A.TOTAL_MB,
       A.FREE_MB,
       A.CREATE_DATE,
       A.MOUNT_DATE,
       A.LIBRARY,
       A.OS_MB
  FROM V$ASM_DISK A
  ORDER BY  A.GROUP_NUMBER,
       A.DISK_NUMBER;
"
},
{
"title":"查询ASM磁盘组的使用情况",
"sql":"SELECT DI.GROUP_NUMBER,
       DI.NAME,
       DI.BLOCK_SIZE,
       DI.STATE,
       DI.TYPE,
       DI.TOTAL_MB,
       DI.FREE_MB,
       DI.COMPATIBILITY,
       DI.VOTING_FILES,
       DI.OFFLINE_DISKS
  FROM V$ASM_DISKGROUP DI
 ORDER BY DI.GROUP_NUMBER;"
},
{
"title":"查询数据库闪回空间的使用情况",
"sql":"通过视图V$RECOVERY_FILE_DEST可以查询闪回空间的使用情况，其SQL如下所示：
SELECT NAME,
       TRUNC(SPACE_LIMIT/1024/1024/1024, 3) LIMIT_GB,
       TRUNC(SPACE_USED/1024/1024/1024, 3) USED_GB,
       TRUNC(SPACE_USED / SPACE_LIMIT, 3) \"USED%\",
       TRUNC(SPACE_RECLAIMABLE, 3) RECLAIM,
       NUMBER_OF_FILES
  FROM V$RECOVERY_FILE_DEST V
 WHERE V.SPACE_LIMIT <> 0;

若想查询详细使用情况，可以执行如下的SQL语句：
SELECT NVL(FRAU.FILE_TYPE, 'Total:') FILE_TYPE,
       SUM(ROUND(FRAU.PERCENT_SPACE_USED / 100 * RFD.SPACE_LIMIT / 1024 / 1024 / 1024,3)) USED_GB,
       SUM(FRAU.PERCENT_SPACE_USED) PERCENT_SPACE_USED,
       SUM(FRAU.PERCENT_SPACE_RECLAIMABLE) PERCENT_SPACE_RECLAIMABLE,
       SUM(ROUND(FRAU.PERCENT_SPACE_RECLAIMABLE / 100 * RFD.SPACE_LIMIT / 1024 / 1024 / 1024,3)) RECLAIM_GB,
       SUM(FRAU.NUMBER_OF_FILES) NUMBER_OF_FILES
  FROM V$FLASH_RECOVERY_AREA_USAGE FRAU, V$RECOVERY_FILE_DEST RFD
 GROUP BY ROLLUP(FILE_TYPE);
"
},
{
"title":"查询到数据库的增长情况",
"sql":"可以通过视图DBA_HIST_TBSPC_SPACE_USAGE来获取数据库的增长情况，具体查询语句及结果如下所示：
SELECT TO_CHAR(DATETIME, 'YYYY-MM-DD') DATETIME,
       TRUNC(SUM(TS_USED_SIZE) / 1024 / 1024) TS_USED_SIZE_M,
       TRUNC(SUM(TS_SIZE) / 1024 / 1024) TS_SIZE_M,
       TRUNC(SUM(TS_MAXSIZE) / 1024 / 1024) TS_MAXSIZE_M
  FROM (SELECT A.NAME, B.*
          FROM V$TABLESPACE A,
               (SELECT TABLESPACE_ID TS#,
                       TRUNC(TO_DATE(RTIME, 'MM/DD/YYYY HH24:MI:SS')) DATETIME,
                       (MAX(TABLESPACE_USEDSIZE * 8 * 1024)) TS_USED_SIZE,
                       (MAX(V.TABLESPACE_SIZE * 8 * 1024)) TS_SIZE,
                       (MAX(TABLESPACE_MAXSIZE * 8 * 1024)) TS_MAXSIZE
                  FROM DBA_HIST_TBSPC_SPACE_USAGE V
                 WHERE TRUNC(TO_DATE(RTIME, 'MM/DD/YYYY HH24:MI:SS')) >=
                       TRUNC(SYSDATE - 15)
                 GROUP BY TABLESPACE_ID,
                          TRUNC(TO_DATE(RTIME, 'MM/DD/YYYY HH24:MI:SS'))
                 ORDER BY TABLESPACE_ID,
                          TRUNC(TO_DATE(RTIME, 'MM/DD/YYYY HH24:MI:SS'))) B
         WHERE A.TS# = B.TS#)
 GROUP BY TO_CHAR(DATETIME, 'YYYY-MM-DD')
 ORDER BY DATETIME;

 若是需要按照表空间来展示，则可以运行如下的代码：
SELECT A.NAME,
       B.TS#,
       TO_CHAR(DATETIME, 'YYYY-MM-DD') DATETIME,
       TS_USED_SIZE_M,
       TS_SIZE_M,
       TS_MAXSIZE_M
  FROM V$TABLESPACE A,
       (SELECT TABLESPACE_ID TS#,
               TRUNC(TO_DATE(RTIME, 'MM/DD/YYYY HH24:MI:SS')) DATETIME,
               TRUNC(MAX(TABLESPACE_USEDSIZE * 8 * 1024)/1024/1024) TS_USED_SIZE_M,
               TRUNC(MAX(V.TABLESPACE_SIZE * 8 * 1024)/1024/1024) TS_SIZE_M,
               TRUNC(MAX(TABLESPACE_MAXSIZE * 8 * 1024)/1024/1024) TS_MAXSIZE_M
          FROM DBA_HIST_TBSPC_SPACE_USAGE V
         WHERE TRUNC(TO_DATE(RTIME, 'MM/DD/YYYY HH24:MI:SS')) >=
               TRUNC(SYSDATE - 7)
         GROUP BY TABLESPACE_ID,
                  TRUNC(TO_DATE(RTIME, 'MM/DD/YYYY HH24:MI:SS'))
         ORDER BY TABLESPACE_ID,
                  TRUNC(TO_DATE(RTIME, 'MM/DD/YYYY HH24:MI:SS'))) B
 WHERE A.TS# = B.TS#
 ORDER BY B.TS#, B.DATETIME;
"
},
{
"title":"如何跟踪expdp和SQL*Plus命令",
"sql":"可以使用trace选项来跟踪expdp命令，如下所示：
expdp \'/ AS SYSDBA\' directory=DATA_PUMP_DIR schemas=SCOTT dumpfile=test_query_lhr_scott_02.dmp parfile=/tmp/scottfile.par log=test_query_lhr_scott_02.log trace=4a0300

若想跟踪exp命令的话，可以使用操作系统命令strace，如下所示：
strace exp n1/n1 tables=scott.emp file=a.dmp

strace -c -p 25805

操作系统命令strace也可以跟踪SQL*Plus命令，跟踪的命令很简单：
strace -o /tmp/output.txt -T -tt -e trace=all  sqlplus / as sysdba

Unix系统下跟踪SQL*Plus命令使用truss命令，如下所示：
truss -dfaie -o /tmp/sched_trace.out.02271 sqlplus '/as sysdba'
"
},
{
"title":"如何彻底停止expdp进程",
"sql","许多同事在使用expdp命令时，不小心按了CTRL+C组合键,然后又输入exit命令（或者网络中断等异常现象），导致expdp进程不存在，但Oracle数据库的会话仍存在，所以dmp文件也一直在增长。在这种情况下的处理办法如下所示：
1、检查expdp进程是否还在
ps -ef | grep expdp
若存在，则可用kill -9 process命令杀掉expdp的进程。

2、检查会话是否仍存在，若存在则把相关的会话杀掉（注意：先使用命令“ALTER SYSTEM KILL SESSION”在数据库级别杀掉会话，然后在OS级别使用kill -9杀掉进程），如无杀会话的权限则可以将相关的表DROP掉，表名可以使用如下的SQL来查询：
SELECT * FROM DBA_DATAPUMP_SESSIONS;
SELECT * FROM DBA_DATAPUMP_JOBS;
例如：
SYS@orclasm > SELECT * FROM DBA_DATAPUMP_SESSIONS;

OWNER_NAME JOB_NAME                     INST_ID SADDR            SESSION_TYPE
---------- ------------------------- ---------- ---------------- --------------
LHR        SYS_EXPORT_SCHEMA_04               1 00000000A8B71D98 MASTER
LHR        SYS_EXPORT_SCHEMA_04               1 00000000AB98AFC8 WORKER

SYS@orclasm > DROP TABLE LHR.SYS_EXPORT_SCHEMA_04 PURGE;
Table dropped.

SYS@orclasm >  SELECT * FROM DBA_DATAPUMP_SESSIONS;
no rows selected

SYS@orclasm > SELECT * FROM DBA_DATAPUMP_JOBS;
no rows selected
使用相同的办法也删除从视图DBA_DATAPUMP_JOBS中查询出来的表，直到2个视图无记录。

3、删除导出的dmp文件。如不删除，则重新执行expdp命令时，会报dmp文件已存在。
这里作者给出自己常用的一个SQL语句，可以查询expdp的相关会话的详细信息，如下所示：

SET LINE 9999
COL OWNER_NAME FOR A10
COL JOB_NAME FOR A25
COL OPERATION FOR A10
COL JOB_MODE FOR A10
COL STATE FOR A15
COL OSUSER FOR A10
COL "DEGREE|ATTACHED|DATAPUMP" FOR A25
COL SESSION_INFO FOR A20  

SELECT DS.INST_ID,
       DJ.OWNER_NAME,
       DJ.JOB_NAME,
       TRIM(DJ.OPERATION) OPERATION,
       TRIM(DJ.JOB_MODE) JOB_MODE,
       DJ.STATE,
       DJ.DEGREE || ',' || DJ.ATTACHED_SESSIONS || ',' ||DJ.DATAPUMP_SESSIONS "DEGREE|ATTACHED|DATAPUMP",
       DS.SESSION_TYPE,
       S.OSUSER ,
       (SELECT S.SID || ',' || S.SERIAL# || ',' || P.SPID
          FROM GV$PROCESS P
         WHERE S.PADDR = P.ADDR
           AND S.INST_ID = P.INST_ID) SESSION_INFO
  FROM DBA_DATAPUMP_JOBS DJ --GV$DATAPUMP_JOB  
  FULL OUTER JOIN DBA_DATAPUMP_SESSIONS DS --GV$DATAPUMP_SESSION
    ON (DJ.JOB_NAME = DS.JOB_NAME AND DJ.OWNER_NAME = DS.OWNER_NAME)
  LEFT OUTER JOIN GV$SESSION S
    ON (S.SADDR = DS.SADDR AND DS.INST_ID = S.INST_ID)
 ORDER BY DJ.OWNER_NAME, DJ.JOB_NAME;
"
}]}]
