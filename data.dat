[{"type":"Oracle","data":[
{"title":"查询RMAN的所有备份信息",
"sql":"SELECT A.RECID BS_KEY,
       C.RECID BP_KEY,
       CASE
         WHEN A.BACKUP_TYPE = 'L' THEN
          'Archived Redo Logs'
         WHEN A.BACKUP_TYPE = 'D' AND A.INCREMENTAL_LEVEL IS NULL THEN
          'Datafile Full Backup'
         WHEN A.BACKUP_TYPE = 'I' OR A.INCREMENTAL_LEVEL IS NOT NULL THEN
          'Incremental Backup'
       END BACKUP_TYPE,
       A.INCREMENTAL_LEVEL,
       AA.BS_BYTES,
       TO_CHAR(A.START_TIME, 'YYYY-MM-DD HH24:MI:SS') START_TIME,
       TO_CHAR(A.COMPLETION_TIME, 'YYYY-MM-DD HH24:MI:SS') END_TIME,
       A.ELAPSED_SECONDS,
       C.HANDLE PIECE_NAME,
       C.DEVICE_TYPE,
       C.TAG,
       AA.BS_STATUS,
       AA.BS_COMPRESSED,
       A.CONTROLFILE_INCLUDED,
       A.KEEP,
       A.KEEP_UNTIL,
       A.KEEP_OPTIONS,
       ------ data file -------- 
       B.FILE#,
       B.INCREMENTAL_LEVEL DF_INCREMENTAL_LEVEL,
       (SELECT NB.NAME FROM V$DATAFILE NB WHERE NB.FILE# = B.FILE#) DATAFILENAME,
       B.USED_CHANGE_TRACKING,
       B.CHECKPOINT_CHANGE# || '' DF_CHECKPOINT_CHANGE#,
       B.CHECKPOINT_TIME DF_CHECKPOINT_TIME,
       ------ archive log file --------
       D.THREAD#,
       D.SEQUENCE#,
       D.RESETLOGS_CHANGE#,
       D.FIRST_CHANGE#,
       D.FIRST_TIME,
       D.NEXT_CHANGE#,
       D.NEXT_TIME,
       ------ spfile --------
       E.MODIFICATION_TIME,
       E.DB_UNIQUE_NAME,
       ------ control file --------
       F.CREATION_TIME,
       F.CHECKPOINT_CHANGE# || '' CF_CHECKPOINT_CHANGE#,
       F.CHECKPOINT_TIME CF_CHECKPOINT_TIME,
       F.FILESIZE_DISPLAY
  FROM V$BACKUP_SET A
  LEFT OUTER JOIN V$BACKUP_FILES AA
    ON (AA.BS_KEY = A.RECID AND AA.FILE_TYPE = 'PIECE')
  LEFT OUTER JOIN V$BACKUP_DATAFILE B
    ON (A.SET_STAMP = B.SET_STAMP AND A.SET_COUNT = B.SET_COUNT)
  LEFT OUTER JOIN V$BACKUP_PIECE C
    ON (A.SET_STAMP = C.SET_STAMP AND A.SET_COUNT = C.SET_COUNT)
  LEFT OUTER JOIN V$BACKUP_ARCHIVELOG_DETAILS D
    ON (D.BTYPE_KEY = A.RECID)
  LEFT OUTER JOIN V$BACKUP_SPFILE E
    ON (A.SET_STAMP = E.SET_STAMP AND A.SET_COUNT = E.SET_COUNT)
  LEFT OUTER JOIN V$BACKUP_CONTROLFILE_DETAILS F
    ON (F.BTYPE_KEY = A.RECID)
 ORDER BY A.RECID, A.RECID, B.FILE#, D.THREAD#, D.SEQUENCE#;
"},
{"title":"查询归档日志的生成情况",
"sql":"通过视图GV$ARCHIVED_LOG可以查询到日志的生成情况，如下所示：
SELECT A.THREAD# THREAD#,
       A.F_TIME F_TIME,
       ROUND(SUM(A.BLOCKS * A.BLOCK_SIZE) / 1024 / 1024) 每天归档日志量_M,
       ROUND(SUM(A.BLOCKS * A.BLOCK_SIZE) / 1024 / 1024 / 24, 2) 每小时平均归档日志量_M,
       COUNT(1)  归档文件数
  FROM (SELECT DISTINCT SEQUENCE#,
                        THREAD#,
                        BLOCKS,
                        BLOCK_SIZE,
                        TO_CHAR(FIRST_TIME, 'yyyy-mm-dd') F_TIME
          FROM GV$ARCHIVED_LOG T
         WHERE T.FIRST_TIME <= SYSDATE) A
 GROUP BY A.F_TIME, A.THREAD#
 ORDER BY 1, 2 DESC;
"},
{
"title":"查询ASM磁盘的使用情况",
"sql":"SELECT A.GROUP_NUMBER,
       A.DISK_NUMBER,
       A.NAME,
       A.PATH,
       A.STATE,
       A.MOUNT_STATUS,
       A.TOTAL_MB,
       A.FREE_MB,
       A.CREATE_DATE,
       A.MOUNT_DATE,
       A.LIBRARY,
       A.OS_MB
  FROM V$ASM_DISK A
  ORDER BY  A.GROUP_NUMBER,
       A.DISK_NUMBER;
"
},
{
"title":"查询ASM磁盘组的使用情况",
"sql":"SELECT DI.GROUP_NUMBER,
       DI.NAME,
       DI.BLOCK_SIZE,
       DI.STATE,
       DI.TYPE,
       DI.TOTAL_MB,
       DI.FREE_MB,
       DI.COMPATIBILITY,
       DI.VOTING_FILES,
       DI.OFFLINE_DISKS
  FROM V$ASM_DISKGROUP DI
 ORDER BY DI.GROUP_NUMBER;"
},
{
"title":"查询数据库闪回空间的使用情况",
"sql":"通过视图V$RECOVERY_FILE_DEST可以查询闪回空间的使用情况，其SQL如下所示：
SELECT NAME,
       TRUNC(SPACE_LIMIT/1024/1024/1024, 3) LIMIT_GB,
       TRUNC(SPACE_USED/1024/1024/1024, 3) USED_GB,
       TRUNC(SPACE_USED / SPACE_LIMIT, 3) \"USED%\",
       TRUNC(SPACE_RECLAIMABLE, 3) RECLAIM,
       NUMBER_OF_FILES
  FROM V$RECOVERY_FILE_DEST V
 WHERE V.SPACE_LIMIT <> 0;

若想查询详细使用情况，可以执行如下的SQL语句：
SELECT NVL(FRAU.FILE_TYPE, 'Total:') FILE_TYPE,
       SUM(ROUND(FRAU.PERCENT_SPACE_USED / 100 * RFD.SPACE_LIMIT / 1024 / 1024 / 1024,3)) USED_GB,
       SUM(FRAU.PERCENT_SPACE_USED) PERCENT_SPACE_USED,
       SUM(FRAU.PERCENT_SPACE_RECLAIMABLE) PERCENT_SPACE_RECLAIMABLE,
       SUM(ROUND(FRAU.PERCENT_SPACE_RECLAIMABLE / 100 * RFD.SPACE_LIMIT / 1024 / 1024 / 1024,3)) RECLAIM_GB,
       SUM(FRAU.NUMBER_OF_FILES) NUMBER_OF_FILES
  FROM V$FLASH_RECOVERY_AREA_USAGE FRAU, V$RECOVERY_FILE_DEST RFD
 GROUP BY ROLLUP(FILE_TYPE);
"
},
{
"title":"查询到数据库的增长情况",
"sql":"可以通过视图DBA_HIST_TBSPC_SPACE_USAGE来获取数据库的增长情况，具体查询语句及结果如下所示：
SELECT TO_CHAR(DATETIME, 'YYYY-MM-DD') DATETIME,
       TRUNC(SUM(TS_USED_SIZE) / 1024 / 1024) TS_USED_SIZE_M,
       TRUNC(SUM(TS_SIZE) / 1024 / 1024) TS_SIZE_M,
       TRUNC(SUM(TS_MAXSIZE) / 1024 / 1024) TS_MAXSIZE_M
  FROM (SELECT A.NAME, B.*
          FROM V$TABLESPACE A,
               (SELECT TABLESPACE_ID TS#,
                       TRUNC(TO_DATE(RTIME, 'MM/DD/YYYY HH24:MI:SS')) DATETIME,
                       (MAX(TABLESPACE_USEDSIZE * 8 * 1024)) TS_USED_SIZE,
                       (MAX(V.TABLESPACE_SIZE * 8 * 1024)) TS_SIZE,
                       (MAX(TABLESPACE_MAXSIZE * 8 * 1024)) TS_MAXSIZE
                  FROM DBA_HIST_TBSPC_SPACE_USAGE V
                 WHERE TRUNC(TO_DATE(RTIME, 'MM/DD/YYYY HH24:MI:SS')) >=
                       TRUNC(SYSDATE - 15)
                 GROUP BY TABLESPACE_ID,
                          TRUNC(TO_DATE(RTIME, 'MM/DD/YYYY HH24:MI:SS'))
                 ORDER BY TABLESPACE_ID,
                          TRUNC(TO_DATE(RTIME, 'MM/DD/YYYY HH24:MI:SS'))) B
         WHERE A.TS# = B.TS#)
 GROUP BY TO_CHAR(DATETIME, 'YYYY-MM-DD')
 ORDER BY DATETIME;

 若是需要按照表空间来展示，则可以运行如下的代码：
SELECT A.NAME,
       B.TS#,
       TO_CHAR(DATETIME, 'YYYY-MM-DD') DATETIME,
       TS_USED_SIZE_M,
       TS_SIZE_M,
       TS_MAXSIZE_M
  FROM V$TABLESPACE A,
       (SELECT TABLESPACE_ID TS#,
               TRUNC(TO_DATE(RTIME, 'MM/DD/YYYY HH24:MI:SS')) DATETIME,
               TRUNC(MAX(TABLESPACE_USEDSIZE * 8 * 1024)/1024/1024) TS_USED_SIZE_M,
               TRUNC(MAX(V.TABLESPACE_SIZE * 8 * 1024)/1024/1024) TS_SIZE_M,
               TRUNC(MAX(TABLESPACE_MAXSIZE * 8 * 1024)/1024/1024) TS_MAXSIZE_M
          FROM DBA_HIST_TBSPC_SPACE_USAGE V
         WHERE TRUNC(TO_DATE(RTIME, 'MM/DD/YYYY HH24:MI:SS')) >=
               TRUNC(SYSDATE - 7)
         GROUP BY TABLESPACE_ID,
                  TRUNC(TO_DATE(RTIME, 'MM/DD/YYYY HH24:MI:SS'))
         ORDER BY TABLESPACE_ID,
                  TRUNC(TO_DATE(RTIME, 'MM/DD/YYYY HH24:MI:SS'))) B
 WHERE A.TS# = B.TS#
 ORDER BY B.TS#, B.DATETIME;
"
},
{
"title":"如何跟踪expdp和SQL*Plus命令",
"sql":"可以使用trace选项来跟踪expdp命令，如下所示：
expdp \'/ AS SYSDBA\' directory=DATA_PUMP_DIR schemas=SCOTT dumpfile=test_query_lhr_scott_02.dmp parfile=/tmp/scottfile.par log=test_query_lhr_scott_02.log trace=4a0300

若想跟踪exp命令的话，可以使用操作系统命令strace，如下所示：
strace exp n1/n1 tables=scott.emp file=a.dmp

strace -c -p 25805

操作系统命令strace也可以跟踪SQL*Plus命令，跟踪的命令很简单：
strace -o /tmp/output.txt -T -tt -e trace=all  sqlplus / as sysdba

Unix系统下跟踪SQL*Plus命令使用truss命令，如下所示：
truss -dfaie -o /tmp/sched_trace.out.02271 sqlplus '/as sysdba'
"
},
{
"title":"如何彻底停止expdp进程",
"sql":"在使用expdp命令时，不小心按了CTRL+C组合键,然后又输入exit命令（或者网络中断等异常现象），导致expdp进程不存在，但Oracle数据库的会话仍存在，所以dmp文件也一直在增长。在这种情况下的处理办法如下所示：
1、检查expdp进程是否还在
ps -ef | grep expdp
若存在，则可用kill -9 process命令杀掉expdp的进程。

2、检查会话是否仍存在，若存在则把相关的会话杀掉（注意：先使用命令“ALTER SYSTEM KILL SESSION”在数据库级别杀掉会话，然后在OS级别使用kill -9杀掉进程），如无杀会话的权限则可以将相关的表DROP掉，表名可以使用如下的SQL来查询：
SELECT * FROM DBA_DATAPUMP_SESSIONS;
SELECT * FROM DBA_DATAPUMP_JOBS;
例如：
SYS@orclasm > SELECT * FROM DBA_DATAPUMP_SESSIONS;
OWNER_NAME JOB_NAME                     INST_ID SADDR            SESSION_TYPE
---------- ------------------------- ---------- ---------------- --------------
LHR        SYS_EXPORT_SCHEMA_04               1 00000000A8B71D98 MASTER
LHR        SYS_EXPORT_SCHEMA_04               1 00000000AB98AFC8 WORKER

SYS@orclasm > DROP TABLE LHR.SYS_EXPORT_SCHEMA_04 PURGE;
Table dropped.

SYS@orclasm >  SELECT * FROM DBA_DATAPUMP_SESSIONS;
no rows selected

SYS@orclasm > SELECT * FROM DBA_DATAPUMP_JOBS;
no rows selected
使用相同的办法也删除从视图DBA_DATAPUMP_JOBS中查询出来的表，直到2个视图无记录。

3、删除导出的dmp文件。如不删除，则重新执行expdp命令时，会报dmp文件已存在。
这里作者给出自己常用的一个SQL语句，可以查询expdp的相关会话的详细信息，如下所示：

SET LINE 9999
COL OWNER_NAME FOR A10
COL JOB_NAME FOR A25
COL OPERATION FOR A10
COL JOB_MODE FOR A10
COL STATE FOR A15
COL OSUSER FOR A10
COL \"DEGREE|ATTACHED|DATAPUMP\" FOR A25
COL SESSION_INFO FOR A20  

SELECT DS.INST_ID,
       DJ.OWNER_NAME,
       DJ.JOB_NAME,
       TRIM(DJ.OPERATION) OPERATION,
       TRIM(DJ.JOB_MODE) JOB_MODE,
       DJ.STATE,
       DJ.DEGREE || ',' || DJ.ATTACHED_SESSIONS || ',' ||DJ.DATAPUMP_SESSIONS \"DEGREE|ATTACHED|DATAPUMP\",
       DS.SESSION_TYPE,
       S.OSUSER ,
       (SELECT S.SID || ',' || S.SERIAL# || ',' || P.SPID
          FROM GV$PROCESS P
         WHERE S.PADDR = P.ADDR
           AND S.INST_ID = P.INST_ID) SESSION_INFO
  FROM DBA_DATAPUMP_JOBS DJ --GV$DATAPUMP_JOB  
  FULL OUTER JOIN DBA_DATAPUMP_SESSIONS DS --GV$DATAPUMP_SESSION
    ON (DJ.JOB_NAME = DS.JOB_NAME AND DJ.OWNER_NAME = DS.OWNER_NAME)
  LEFT OUTER JOIN GV$SESSION S
    ON (S.SADDR = DS.SADDR AND DS.INST_ID = S.INST_ID)
 ORDER BY DJ.OWNER_NAME, DJ.JOB_NAME;
"
},
{
"title":"RMAN可以跨版本恢复吗",
"sql":"答案是可以跨版本恢复的，但是有很多限制条件。对于跨小版本的恢复很容易，例如从11.2.0.1恢复到11.2.0.3版本的数据库。可以依次还原SPFILE、控制文件和数据文件，然后恢复数据库，使用STARTUP UPGRADE命令打开数据库，最后一步是使用catupgrd.sql脚本对失效的对象进行编译即可。对于跨大版本的恢复有很多限制条件，例如从10.2.0.2恢复到11.2.0.3版本的数据库。恢复步骤和小版本一样，打开数据库的时候可以使用命令：“ALTER DATABASE OPEN RESETLOGS UPGRADE;”。将Oracle 10g恢复到Oracle 11g上，需要满足2个条件，①必须在Oracle 10g上先执行脚本“@?/rdbms/admin/utlu112i.sql”，然后再进行备份，否则RESTORE之后的升级将失败。②Oracle 10g的版本必须大于10.2.0.2，即Oracle采用RMAN恢复到高版本的数据库依然要遵循Oracle数据库的升级流程图"
},
{
"title":"在UNDO表空间数据文件丢失的情况下如何恢复",
"sql":"恢复大约可以分为3种情况：
①有备份，这种情况下直接采用备份的文件进行恢复即可。
②无备份但是有完整的归档文件存在，这种情况下可以使用命令“ALTER DATABASE CREATE DATAFILE 文件号 AS '/u03/app/oracle/oradata/ora1024g/undotbs01.dbf' size 50m;”来创建丢失的UNDO文件，然后使用“RECOVER DATAFILE 文件号;”进行恢复数据库文件即可。
③无备份归档文件丢失，在这种情况下的恢复比较复杂。首先应该切换UNDO表空间到一个新建的UNDO表空间中，并设置原有表空间的管理模式为手动管理模式，然后将隐含参数“_OFFLINE_ROLLBACK_SEGMENTS”设置为TRUE，一些关键性的命令如下所示：
ALTER SYSTEM SET UNDO_TABLESPACE=UNDOTBS2 SCOPE=SPFILE;
ALTER SYSTEM SET UNDO_MANAGEMENT=MANUAL SCOPE=SPFILE;
ALTER SYSTEM SET \"_OFFLINE_ROLLBACK_SEGMENTS\"=TRUE SCOPE=SPFILE;
ALTER SYSTEM SET \"_CORRUPTED_ROLLBACK_SEGMENTS\"='_SYSSMU1$','_SYSSMU2$','_SYSSMU3$','_SYSSMU4$','_SYSSMU5$','_SYSSMU6$','_SYSSMU7$','_SYSSMU8$','_SYSSMU9$','_SYSSMU10$' SCOPE=SPFILE;
CREATE UNDO TABLESPACE UNDOTBS1 DATAFILE '/U03/APP/ORACLE/ORADATA/ORA1024G/UNDOTBS01.DBF' SIZE 50M AUTOEXTEND ON;
ALTER SYSTEM SET UNDO_TABLESPACE=UNDOTBS1  SCOPE=SPFILE;
ALTER SYSTEM SET UNDO_MANAGEMENT=AUTO  SCOPE=SPFILE;
ALTER SYSTEM RESET \"_OFFLINE_ROLLBACK_SEGMENTS\" SCOPE=SPFILE SID='*';
ALTER SYSTEM RESET \"_CORRUPTED_ROLLBACK_SEGMENTS\" SCOPE=SPFILE SID='*';
"
},
{
"title":"数据泵中NETWORK_LINK选项的作用是什么",
"sql":"数据泵expdp生成的文件默认是存放在服务端的，而exp生成的文件是存放在客户端的。使用数据泵的NETWORK_LINK参数，可以在本地的数据库中创建一个指向远程数据库的DBLINK，在执行导出expdp时，指定NETWORK_LINK参数为DBLINK名称，就可以直接将远程数据库的数据导出到本地数据库里创建的DIRECTORY下。在执行导入命令impdp的时候也可以使用NETWORK_LINK参数。如果不想在源端或目标端生成dmp文件而直接将需要的数据导入目标端数据库，那么可以直接使用impdp带NETWORK_LINK参数，这样可以直接执行impdp从而绕过了expdp的步骤。"
},
{
"title":"TWO_TASK环境变量的作用是什么",
"sql":"在Linux环境下，可以设置TWO_TASK环境变量，当用户连接数据库且没有指定服务名时，会自动利用TWO_TASK的设置作为环境变量连接数据库。其中，TWO_TASK的值为tnsnames.ora文件中配置的值。示例如下所示：
[LHRDB1:oracle]:/oracle>ORACLE_SID=
[LHRDB1:oracle]:/oracle>TWO_TASK=
[LHRDB1:oracle]:/oracle>sqlplus lhr/lhr
SQL*Plus: Release 11.2.0.4.0 Production on Mon Oct 31 16:17:38 2016
Copyright (c) 1982, 2013, Oracle.  All rights reserved.
ERROR:
ORA-12162: TNS:net service name is incorrectly specified
[LHRDB1:oracle]:/oracle>more $ORACLE_HOME/net*/ad*/tns*
# tnsnames.ora Network Configuration File: /oracle/app/oracle/product/11.2.0/db/network/admin/tnsnames.ora
# Generated by Oracle configuration tools.
lhrdb =
  (DESCRIPTION =
    (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.59.130)(PORT = 1521)) 
    (CONNECT_DATA =
      (SERVER = DEDICATED)
      (SERVICE_NAME = lhrdb)
    )
  )
[LHRDB1:oracle]:/oracle>export TWO_TASK=lhrdb
[LHRDB1:oracle]:/oracle>sqlplus lhr/lhr
SQL*Plus: Release 11.2.0.4.0 Production on Mon Oct 31 16:17:53 2016
Copyright (c) 1982, 2013, Oracle.  All rights reserved.
Connected to:
Oracle Database 11g Enterprise Edition Release 11.2.0.4.0 - 64bit Production
With the Partitioning, Real Application Clusters, Automatic Storage Management, OLAP,
Data Mining and Real Application Testing options
LHR@lhrdb> 
[LHRDB1:oracle]:/oracle>sqlplus / as sysdba
SQL*Plus: Release 11.2.0.4.0 Production on Mon Oct 31 16:18:07 2016
Copyright (c) 1982, 2013, Oracle.  All rights reserved.
ERROR:
ORA-01017: invalid username/password; logon denied
Enter user-name: 

需要注意的是，当配置了TWO_TASK环境变量后，就无法使用操作系统验证来登录数据库了，会报ORA-01031: insufficient privileges的错误。

类似地，在Windows环境下的变量是LOCAL，其设置方法和Linux下的TWO_TASK一致，如下所示：
C:\\Users\\boc>sqlplus lhr/lhr
SQL*Plus: Release 11.2.0.1.0 Production on Mon Oct 31 16:28:25 2016
Copyright (c) 1982, 2010, Oracle.  All rights reserved.
ERROR:
ORA-12560: TNS:protocol adapter error
Enter user-name:
C:\\Users\\boc>more \"%ORACLE_HOME%/network/admin/tnsnames.ora\"
# tnsnames.ora Network Configuration File: D:\\app\\oracle\\product\\11.2.0.1\\network\\admin\\tnsnames.ora
# Generated by Oracle configuration tools.
lhrdb =
  (DESCRIPTION =
    (ADDRESS = (PROTOCOL = TCP)(HOST = 22.188.194.64)(PORT = 1521))
    (CONNECT_DATA =
      (SERVER = DEDICATED)
      (SERVICE_NAME = lhrdb)
    )
  )
C:\\Users\\boc>set LOCAL=lhrdb
C:\\Users\\boc>sqlplus lhr/lhr
SQL*Plus: Release 11.2.0.1.0 Production on Mon Oct 31 16:29:25 2016
Copyright (c) 1982, 2010, Oracle.  All rights reserved.
Connected to:
Oracle Database 11g Enterprise Edition Release 11.2.0.4.0 - 64bit Production
With the Partitioning, Real Application Clusters, Automatic Storage Management, OLAP,
Data Mining and Real Application Testing options
SQL> 
"
},
{
"title":"如何查询数据库系统或当前会话的REDO和UNDO的生成量",
"sql":"反映UNDO、REDO生成量的统计指标分别是：
REDO：redo size
UNDO：undo change vector size
1、查询数据库系统REDO生成量，可以通过V$SYSSTAT视图查询，如下所示：
SELECT NAME,
       VALUE
FROM   V$SYSSTAT
WHERE  NAME = 'redo size';
 
2、查看当前会话的REDO生成量，可以通过V$MYSTAT或V$SESSTAT视图查询，如下所示：
CREATE OR REPLACE VIEW REDO_SIZE AS
SELECT VALUE
FROM   V$MYSTAT   MY,
       V$STATNAME  ST
WHERE  MY.STATISTIC# =ST.STATISTIC#
AND    ST.NAME = 'redo size';

可以创建视图来同时查询当前会话REDO和UNDO的生成量，如下所示：
CREATE OR REPLACE VIEW VW_REDO_UNDO_LHR AS
SELECT (SELECT NB.VALUE
          FROM V$MYSTAT NB, V$STATNAME ST
         WHERE NB.STATISTIC# = ST.STATISTIC#
           AND ST.NAME = 'redo size') REDO,
       (SELECT NB.VALUE
          FROM V$MYSTAT NB, V$STATNAME ST
         WHERE NB.STATISTIC# = ST.STATISTIC#
           AND ST.NAME = 'undo change vector size') UNDO
  FROM DUAL;
"
},
{
"title":"如何找出当前有多少个用户登录到数据库",
"sql":"有多种方式可以查询，其中，一种方式是查询V$SESSION视图，SQL命令为：“SELECT COUNT(1) FROM V$SESSION  A”，另一种方式是查询V$SYSSTAT视图，SQL命令为：“SELECT * FROM  V$SYSSTAT A WHERE A.NAME='logons current'”。如果是UNIX系统的话，那么还可以通过命令“ps -ef|grep oracle|wc -l”来查询用户数量。"
},
{
"title":"sqlnet.ora文件的作用是什么",
"sql":"sqlnet.ora文件的作用类似于Linux系统的nsswitch.conf文件，通过该文件来决定如何查找一个连接中出现的连接字符串。
例如，在客户端输入命令：sqlplus sys/oracle@orcl，而sqlnet.ora的配置如下所示：
SQLNET.AUTHENTICATION_SERVICES= (NTS)

NAMES.DIRECTORY_PATH= (TNSNAMES,HOSTNAME)
那么，客户端就会首先在tnsnames.ora文件中查找orcl的记录。若没有相应的记录则尝试把orcl当作一个主机名，通过网络的途径去解析它的IP地址，然后去连接这个IP上GLOBAL_DBNAME=orcl实例。
如果sqlnet.ora文件的配置如下所示：
NAMES.DIRECTORY_PATH= (TNSNAMES)
那么客户端就只会从tnsnames.ora查找orcl的记录。
"
},
{
"title":"创建ASM磁盘的方式有哪几种",
"sql":"可以通过ASMLIB、udev及Faking的方式来创建ASM磁盘。其中，Faking的方式不需要额外添加磁盘，可以在现有文件系统上分配一些空间用于ASM磁盘，过程如下所示：
mkdir  -p  /oracle/asmdisk
dd if=/dev/zero of=/oracle/asmdisk/disk1 bs=1024k count=1000
dd if=/dev/zero of=/oracle/asmdisk/disk2 bs=1024k count=1000

/sbin/losetup /dev/loop1 /oracle/asmdisk/disk1
/sbin/losetup /dev/loop2 /oracle/asmdisk/disk2

raw /dev/raw/raw1 /dev/loop1
raw /dev/raw/raw2 /dev/loop2

chmod 660 /dev/raw/raw1
chmod 660 /dev/raw/raw2
chown oracle:dba /dev/raw/raw1
chown oracle:dba /dev/raw/raw2

将以下内容添加到文件/etc/rc.local文件中：
/sbin/losetup /dev/loop1 /oracle/asmdisk/disk1
/sbin/losetup /dev/loop2 /oracle/asmdisk/disk2

raw /dev/raw/raw1 /dev/loop1
raw /dev/raw/raw2 /dev/loop2

chmod 660 /dev/raw/raw1
chmod 660 /dev/raw/raw2
chown oracle:dba /dev/raw/raw1
chown oracle:dba /dev/raw/raw2 
"}
,
{
"title":"RAC等待事件gc buffer busy acquire和gc buffer busy release的区别是什么",
"sql":"gc buffer busy是RAC数据库中常见的等待事件，从Oracle 11g开始gc buffer busy分为gc buffer busy acquire和gc buffer busy release。
gc buffer busy acquire是当会话1尝试请求访问远程实例上的数据块，但是在会话1之前已经有相同实例上另外一个会话2请求访问了相同的数据块，并且没有完成，那么会话1等待gc buffer busy acquire。
gc buffer busy release是在会话1之前已经有远程实例的会话2请求访问了相同的数据块，并且没有完成，那么会话1等待gc buffer busy release。
"
},
{
"title":"RAC下如何在当前的实例下杀掉另外一个实例的会话",
"sql":"在Oracle 11g中很好实现，只需要在命令“ALTER SYSTEM KILL SESSION 'SID,SERIAL#' IMMEDIATE;”中的SERIAL#后加上实例号即可，如果要杀掉实例2上的“71，20925”的会话，那么在任意一个节点上执行：“ALTER SYSTEM DISCONNECT SESSION '71,20925,@2' IMMEDIATE;”即可，但是Oracle 11g以下版本的RAC中就只能连接到相应的实例上才能杀掉当前实例的会话。其实，有一种折中的办法就是创建JOB，让该JOB可以在指定的实例上运行KILL SESSION的命令。"
},
{
"title":"查找最近一分钟内，最消耗CPU的SQL语句",
"sql":"SELECT ASH.INST_ID,
        ASH.SQL_ID,
        (SELECT VS.SQL_TEXT
           FROM GV$SQLAREA VS
          WHERE VS.SQL_ID = ASH.SQL_ID
            AND ASH.INST_ID = VS.INST_ID) SQL_TEXT,
        ASH.SQL_CHILD_NUMBER,
        ASH.SQL_OPNAME,
        ASH.SESSION_INFO,
        COUNTS,
        PCTLOAD * 100 || '%' PCTLOAD
   FROM (SELECT ASH.INST_ID,
                ASH.SQL_ID,
                ASH.SQL_CHILD_NUMBER,
                ASH.SQL_OPNAME,
                (ASH.MODULE || '--' || ASH.ACTION || '--' || ASH.PROGRAM || '--' ||
                ASH.MACHINE || '--' || ASH.CLIENT_ID || '--' ||
                ASH.SESSION_TYPE) SESSION_INFO,
                COUNT(*) COUNTS,
                ROUND(COUNT(*) / SUM(COUNT(*)) OVER(), 2) PCTLOAD,
                DENSE_RANK() OVER(ORDER BY COUNT(*) DESC) RANK_ORDER
           FROM GV$ACTIVE_SESSION_HISTORY ASH
           WHERE  ASH.SESSION_TYPE <> 'BACKGROUND'
           AND ASH.SESSION_STATE = 'ON CPU'
AND SAMPLE_TIME > SYSDATE - 1 / (24 * 60)
          GROUP BY ASH.INST_ID,
                   ASH.SQL_ID,
                   ASH.SQL_CHILD_NUMBER,
                   ASH.SQL_OPNAME,
                   (ASH.MODULE || '--' || ASH.ACTION || '--' || ASH.PROGRAM || '--' ||
                   ASH.MACHINE || '--' || ASH.CLIENT_ID || '--' ||
                   ASH.SESSION_TYPE)) ASH
  WHERE RANK_ORDER <= 10
  ORDER BY COUNTS DESC;
"}
,
{
"title":"查找最近一分钟内，最消耗CPU的会话",
"sql":"SELECT SESSION_ID,
       COUNT(*)
FROM   V$ACTIVE_SESSION_HISTORY V
WHERE  V.SESSION_STATE = 'ON CPU'
AND    V.SAMPLE_TIME > SYSDATE - 10/ (24 * 60)
GROUP  BY SESSION_ID
ORDER  BY COUNT(*) DESC;
"},
{
"title":"查找最近一分钟内，最消耗I/O的SQL语句",
"sql":"SELECT ASH.INST_ID,
        ASH.SQL_ID,
        (SELECT VS.SQL_TEXT
           FROM GV$SQLAREA VS
          WHERE VS.SQL_ID = ASH.SQL_ID
            AND ASH.INST_ID = VS.INST_ID) SQL_TEXT,
        ASH.SQL_CHILD_NUMBER,
        ASH.SQL_OPNAME,
        ASH.SESSION_INFO,
        COUNTS,
        PCTLOAD * 100 || '%' PCTLOAD
   FROM (SELECT ASH.INST_ID,
                ASH.SQL_ID,
                ASH.SQL_CHILD_NUMBER,
                ASH.SQL_OPNAME,
                (ASH.MODULE || '--' || ASH.ACTION || '--' || ASH.PROGRAM || '--' ||
                ASH.MACHINE || '--' || ASH.CLIENT_ID || '--' ||
                ASH.SESSION_TYPE) SESSION_INFO,
                COUNT(*) COUNTS,
                ROUND(COUNT(*) / SUM(COUNT(*)) OVER(), 2) PCTLOAD,
                DENSE_RANK() OVER(ORDER BY COUNT(*) DESC) RANK_ORDER
           FROM GV$ACTIVE_SESSION_HISTORY ASH
          WHERE ASH.SESSION_TYPE <> 'BACKGROUND'
            AND ASH.SESSION_STATE = 'WAITING'
            AND ASH.SAMPLE_TIME > SYSDATE - 1 / (24 * 60)
            AND ASH.WAIT_CLASS = 'USER I/O'
          GROUP BY ASH.INST_ID,
                   ASH.SQL_ID,
                   ASH.SQL_CHILD_NUMBER,
                   ASH.SQL_OPNAME,
                   (ASH.MODULE || '--' || ASH.ACTION || '--' || ASH.PROGRAM || '--' ||
                   ASH.MACHINE || '--' || ASH.CLIENT_ID || '--' ||
                   ASH.SESSION_TYPE)) ASH
  WHERE RANK_ORDER <= 10
  ORDER BY COUNTS DESC;
"
},
{
"title":"查找最近一分钟内，最消耗资源的SQL语句",
"sql":"SELECT ASH.INST_ID,
        ASH.SQL_ID,
        (SELECT VS.SQL_TEXT
           FROM GV$SQLAREA VS
          WHERE VS.SQL_ID = ASH.SQL_ID
            AND ASH.INST_ID = VS.INST_ID) SQL_TEXT,
        ASH.SQL_CHILD_NUMBER,
        ASH.SQL_OPNAME,
        ASH.SESSION_INFO,
        COUNTS,
        PCTLOAD * 100 || '%' PCTLOAD
   FROM (SELECT ASH.INST_ID,
                ASH.SQL_ID,
                ASH.SQL_CHILD_NUMBER,
                ASH.SQL_OPNAME,
                (ASH.MODULE || '--' || ASH.ACTION || '--' || ASH.PROGRAM || '--' ||
                ASH.MACHINE || '--' || ASH.CLIENT_ID || '--' ||
                ASH.SESSION_TYPE) SESSION_INFO,
                COUNT(*) COUNTS,
                ROUND(COUNT(*) / SUM(COUNT(*)) OVER(), 2) PCTLOAD,
                DENSE_RANK() OVER(ORDER BY COUNT(*) DESC) RANK_ORDER
           FROM GV$ACTIVE_SESSION_HISTORY ASH
          WHERE ASH.SESSION_TYPE <> 'BACKGROUND'
            AND ASH.SESSION_STATE = 'WAITING'
            AND ASH.SAMPLE_TIME > SYSDATE - 1 / (24 * 60)
            AND ASH.WAIT_CLASS = 'USER I/O'
          GROUP BY ASH.INST_ID,
                   ASH.SQL_ID,
                   ASH.SQL_CHILD_NUMBER,
                   ASH.SQL_OPNAME,
                   (ASH.MODULE || '--' || ASH.ACTION || '--' || ASH.PROGRAM || '--' ||
                   ASH.MACHINE || '--' || ASH.CLIENT_ID || '--' ||
                   ASH.SESSION_TYPE)) ASH
  WHERE RANK_ORDER <= 10
  ORDER BY COUNTS DESC;
"
},
{
"title":"查找最近一分钟内，最消耗资源的会话",
"sql":"SELECT ASH.SESSION_ID,
       ASH.SESSION_SERIAL#,
       ASH.USER_ID,
       ASH.PROGRAM,
       SUM(DECODE(ASH.SESSION_STATE, 'ON CPU', 1, 0)) \"CPU\",
       SUM(DECODE(ASH.SESSION_STATE, 'WAITING', 1, 0)) -
       SUM(DECODE(ASH.SESSION_STATE,
                  'WAITING',
                  DECODE(ASH.WAIT_CLASS, 'USER I/O', 1, 0),
                  0)) \"WAITING\",
       SUM(DECODE(ASH.SESSION_STATE,
                  'WAITING',
                  DECODE(ASH.WAIT_CLASS, 'USER I/O', 1, 0),
                  0)) \"IO\",
       SUM(DECODE(ASH.SESSION_STATE, 'ON CPU', 1, 1)) \"TOTAL\"
  FROM V$ACTIVE_SESSION_HISTORY ASH
 WHERE ASH.SAMPLE_TIME > SYSDATE - 1 / (24 * 60)
 GROUP BY ASH.SESSION_ID, ASH.USER_ID, ASH.SESSION_SERIAL#, ASH.PROGRAM
 ORDER BY SUM(DECODE(ASH.SESSION_STATE, 'ON CPU', 1, 1));
"},
{
"title":"如何查询逻辑读、物理读、执行次数和解析次数最多以及执行时间最长的SQL语句呢？如何寻找或监控效率低下的SQL语句？",
"sql":"效率低下的SQL一般是执行时间较长的SQL语句，可以通过如下几种方式来监控分析：
①　当前系统的SQL可以通过监控V$SQL_MONITOR、V$SESSION视图来实现，记录执行时间较长的SQL语句。对于历史SQL可以通过分析DBA_HIST_SQLSTAT视图。
②　分析现有的系统中的执行计划，重点检查驱动表与被驱动表顺序、表连接算法、排序是否有索引、索引使用。
③　分析AWR、ASH和ADDM。
④　通过OEM中性能监控的捕获5s以上的SQL。
⑤　通过GV$SQLAREA视图来分析。
如下的SQL语句是查询执行时间最长的SQL语句，若要查询其它性能问题，可以将SQL中加粗的字段替换即可。逻辑读取BUFFER_GETS字段，物理读取DISK_READS字段，执行时间取ELAPSED_TIME字段，执行次数取EXECUTIONS字段，解析次数取PARSE_CALLS字段
SELECT INST_ID,
       USERNAME,
       SQL_ID,
       A.BUFFER_GETS BUFFER_GETS,
       DISK_READS,
       LAST_LOAD_TIME,
       LAST_ACTIVE_TIME,
       A.EXECUTIONS,
       PARSE_CALLS,
       VERSION_COUNT,
       LOADS,
       ((ELAPSED_TIME / 1000000)) ELAPSED_TIME,
       ROUND(A.BUFFER_GETS / DECODE(A.EXECUTIONS, 0, 1, A.EXECUTIONS), 3) BUFFER_GETS_PER_EXEC,
       ROUND(A.DISK_READS / DECODE(A.EXECUTIONS, 0, 1, A.EXECUTIONS), 3) DISK_READS_PER_EXEC,
       (A.ELAPSED_TIME / 1000000 / DECODE(A.EXECUTIONS, 0, 1, A.EXECUTIONS)) ELAPSED_TIME_PER_EXEC,
       CLIENT_INFO,
       A.SQL_TEXT SQL_TEXT
  FROM (SELECT AI.INST_ID,
               AI.BUFFER_GETS,
               AI.DISK_READS,
               AI.EXECUTIONS,
               AI.PARSE_CALLS,
               AI.SQL_TEXT,
               AI.PARSING_USER_ID,
               AI.SQL_ID,
               AI.ELAPSED_TIME,
               AI.LAST_LOAD_TIME,
               AI.LAST_ACTIVE_TIME,
               PARSING_SCHEMA_NAME USERNAME,
               VERSION_COUNT,
               LOADS,
               AI.MODULE || '--' || AI.ACTION CLIENT_INFO,
               RANK() OVER(ORDER BY AI.ELAPSED_TIME DESC) RANK_ORDER
          FROM GV$SQLAREA AI
         WHERE BUFFER_GETS > 1000 ) A
 WHERE RANK_ORDER <= 10
 ORDER BY INST_ID, A.ELAPSED_TIME DESC;
"
},
{
"title":"数据块，重做日志块及控制文件数据块的大小分别是多少",
"sql":"这3种数据块分别介绍如下：
①　数据块（Data Block），是读写数据文件的最小单位，默认是8KB，可以通过SQL语句“SELECT FILE#,NAME,BLOCK_SIZE FROM V$DATAFILE;”查询，单位为BYTE。
②　重做日志数据块（Redo Block），大小一般等于操作系统的系统块的大小，一般为512或4096，可以通过SQL语句“SELECT BLOCKSIZE FROM V$LOG;”或“SELECT LEBSZ FROM X$KCCLE;”查询，单位为BYTE。
③　控制文件数据块（Control File Block），默认为16KB，可以通过SQL语句“SELECT BLOCK_SIZE FROM V$CONTROLFILE;”查询，单位为BYTE。
SQL> col name for a50
SQL> select file#,name,block_size from v$datafile;
     FILE# NAME                                               BLOCK_SIZE
---------- -------------------------------------------------- ----------
         1 /u02/app/oracle/oradata/oratest/system01.dbf             8192
         2 /u02/app/oracle/oradata/oratest/sysaux01.dbf             8192
         3 /u02/app/oracle/oradata/oratest/undotbs01.dbf            8192
         4 /u02/app/oracle/oradata/oratest/users01.dbf              8192
         5 /u02/app/oracle/oradata/oratest/example01.dbf            8192
         6 /u02/app/oracle/oradata/oratest/users02.dbf              8192
         7 /u02/app/oracle/oradata/oratest/ts_ogg01.dbf             8192
         8 /u02/app/oracle/oradata/oratest/users03.dbf              8192 

8 rows selected.
 
SQL> select lebsz from x$kccle;
     LEBSZ
----------
       512
       512
       512

SQL> select block_size from v$controlfile;
BLOCK_SIZE
----------
     16384
     16384
"
}
]}]
